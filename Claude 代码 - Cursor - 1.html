<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ²™ç›’ç»˜ç”»åˆ›é€ æ¸¸æˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .toolbar {
            background: #2c3e50;
            color: white;
            padding: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .tool-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .tool-btn {
            background: #34495e;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .tool-btn:hover {
            background: #3498db;
        }
        
        .tool-btn.active {
            background: #e74c3c;
        }
        
        .color-picker {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .slider {
            width: 100px;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            background: white;
        }
        
        #gameCanvas {
            cursor: crosshair;
            display: block;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 200px;
        }
        
        .objects-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 250px;
        }
        
        .collision-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 200px;
            display: none;
        }
        
        .collision-panel.show {
            display: block;
        }
        
        .collision-option {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }
        
        .collision-option input[type="checkbox"] {
            margin: 0;
        }
        
        .collision-option {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }
        
        .collision-impact {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        
        .impact-slider {
            width: 100%;
            height: 4px;
            background: #555;
            border-radius: 2px;
            outline: none;
        }
        
        .impact-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .impact-value {
            font-size: 10px;
            color: #ccc;
            text-align: center;
        }
        
        .type-selector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 1000;
        }
        
        .type-selector.show {
            display: block;
        }
        
        .type-option {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #34495e;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            text-align: left;
        }
        
        .type-option:hover {
            background: #3498db;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="toolbar">
            <div class="tool-group">
                <button class="tool-btn active" id="drawTool">ğŸ–Šï¸ ç»˜ç”»</button>
                <button class="tool-btn" id="moveTool">âœ‹ ç§»åŠ¨</button>
                <button class="tool-btn" id="selectTool">ğŸ“¦ é€‰æ‹©</button>
                <button class="tool-btn" id="deleteTool">ğŸ—‘ï¸ åˆ é™¤</button>
            </div>
            
            <div class="tool-group">
                <label>é¢œè‰²:</label>
                <input type="color" class="color-picker" id="colorPicker" value="#000000">
            </div>
            
            <div class="tool-group">
                <label>çº¿å®½:</label>
                <input type="range" class="slider" id="brushSize" min="1" max="10" value="3">
                <span id="brushSizeValue">3</span>
            </div>
            
            <div class="tool-group">
                <button class="tool-btn" id="clearCanvas">ğŸ§¹ æ¸…ç©º</button>
                <button class="tool-btn" id="groupObjects">ğŸ”— ç»„åˆ</button>
                <button class="tool-btn" id="ungroupObjects">ğŸ”“ å–æ¶ˆç»„åˆ</button>
                <button class="tool-btn" id="changeTypeTool">ğŸ”„ æ”¹å˜ç±»å‹</button>
            </div>
            
            <div class="tool-group">
                <button class="tool-btn" id="physicsToggle">âš¡ ç‰©ç†</button>
                <button class="tool-btn" id="animateToggle">ğŸ¬ åŠ¨ç”»</button>
                <button class="tool-btn" id="controlToggle">ğŸ® é”®ç›˜æ§åˆ¶</button>
                <button class="tool-btn" id="collisionDebugToggle">ğŸ” ç¢°æ’è°ƒè¯•</button>
            </div>
            
            <div class="tool-group">
                <label>ç¢°æ’ç²¾åº¦:</label>
                <input type="range" class="slider" id="collisionPrecision" min="1" max="10" value="5">
                <span id="collisionPrecisionValue">5</span>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="gameCanvas"></canvas>
            
            <div class="info-panel">
                <h4>æ“ä½œè¯´æ˜:</h4>
                <p>â€¢ ç»˜ç”»ï¼šæ‹–æ‹½ç”»çº¿</p>
                <p>â€¢ ç§»åŠ¨ï¼šæ‹–æ‹½ç‰©ä½“</p>
                <p>â€¢ é€‰æ‹©ï¼šæ¡†é€‰ç‰©ä½“</p>
                <p>â€¢ æ”¹å˜ç±»å‹ï¼šç‚¹å‡»ç‰©ä½“æ”¹å˜å…¶èº«ä»½</p>
                <p>â€¢ ç‰©ç†ï¼šé‡åŠ›æ•ˆæœ</p>
                <p>â€¢ åŠ¨ç”»ï¼šç«æŸ´äººåŠ¨èµ·æ¥</p>
                <p>â€¢ é”®ç›˜æ§åˆ¶ï¼šWASDæˆ–æ–¹å‘é”®ç§»åŠ¨é€‰ä¸­çš„ç«æŸ´äºº</p>
                <p>â€¢ äº’åŠ¨åŠŸèƒ½ï¼šEé”®æ‹¾å–/æ”¾ä¸‹é™„è¿‘çš„ç‰©ä½“ï¼ˆä»…ç«æŸ´äººï¼‰</p>
                <p>â€¢ ç¢°æ’è°ƒè¯•ï¼šæ˜¾ç¤ºç¢°æ’æ£€æµ‹çš„å¯è§†åŒ–æ•ˆæœ</p>
                <p>â€¢ ç¢°æ’è®¾ç½®ï¼šæ§åˆ¶å“ªäº›ç±»å‹å‚ä¸ç¢°æ’</p>
                <p>â€¢ ç¢°æ’å½±å“ï¼šæ§åˆ¶ä¸åŒç±»å‹è¢«ç¢°æ’å½±å“çš„ç¨‹åº¦</p>
                <p>â€¢ ç¢°æ’ç²¾åº¦ï¼šæ§åˆ¶ç¢°æ’æ£€æµ‹çš„ç²¾ç¡®åº¦ï¼ˆ1-10ï¼‰</p>
                <p>â€¢ å¹³å°å½±å“ä¸º0æ—¶ä»å¯è·³è·ƒï¼Œä½†å¹³å°ä¸ä¼šç§»åŠ¨</p>
                <div id="collisionInfo" style="margin-top: 10px; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 3px;">
                    <small>å½“å‰ç¢°æ’ç²¾åº¦: <span id="currentPrecision">5</span><br>
                    ç¢°æ’å®¹å·®: <span id="currentTolerance">2.0</span></small>
                </div>
            </div>
            
            <div class="objects-panel">
                <h4>åˆ›å»ºçš„ç‰©ä½“:</h4>
                <div id="objectsList">æš‚æ— </div>
            </div>
            
            <div class="collision-panel" id="collisionPanel">
                <h4>ç¢°æ’è®¾ç½®:</h4>
                <div class="collision-option">
                    <input type="checkbox" id="collisionStickman" checked>
                    <label for="collisionStickman">ç«æŸ´äºº</label>
                </div>
                <div class="collision-option">
                    <input type="checkbox" id="collisionCircle" checked>
                    <label for="collisionCircle">åœ†å½¢</label>
                </div>
                <div class="collision-option">
                    <input type="checkbox" id="collisionPlatform" checked>
                    <label for="collisionPlatform">å¹³å°</label>
                </div>
                <div class="collision-option">
                    <input type="checkbox" id="collisionDrawing" checked>
                    <label for="collisionDrawing">ç»˜ç”»</label>
                </div>
                <div class="collision-option">
                    <input type="checkbox" id="collisionGroup" checked>
                    <label for="collisionGroup">ç»„åˆç‰©ä½“</label>
                </div>
                
                <h4>ç¢°æ’å½±å“ç¨‹åº¦:</h4>
                <div class="collision-impact">
                    <label>ç«æŸ´äººå½±å“: <span id="impactStickmanValue">100%</span></label>
                    <input type="range" class="impact-slider" id="impactStickman" min="0" max="100" value="100">
                </div>
                <div class="collision-impact">
                    <label>åœ†å½¢å½±å“: <span id="impactCircleValue">100%</span></label>
                    <input type="range" class="impact-slider" id="impactCircle" min="0" max="100" value="100">
                </div>
                <div class="collision-impact">
                    <label>å¹³å°å½±å“: <span id="impactPlatformValue">0%</span></label>
                    <input type="range" class="impact-slider" id="impactPlatform" min="0" max="100" value="0">
                </div>
                <div class="collision-impact">
                    <label>ç»˜ç”»å½±å“: <span id="impactDrawingValue">100%</span></label>
                    <input type="range" class="impact-slider" id="impactDrawing" min="0" max="100" value="100">
                </div>
                <div class="collision-impact">
                    <label>ç»„åˆç‰©ä½“å½±å“: <span id="impactGroupValue">100%</span></label>
                    <input type="range" class="impact-slider" id="impactGroup" min="0" max="100" value="100">
                </div>
            </div>
        </div>
        
        <div class="type-selector" id="typeSelector">
            <h4>é€‰æ‹©æ–°çš„ç±»å‹:</h4>
            <button class="type-option" data-type="stickman">ğŸ§ ç«æŸ´äºº</button>
            <button class="type-option" data-type="circle">â­• åœ†å½¢</button>
            <button class="type-option" data-type="platform">ğŸ—ï¸ å¹³å°</button>
            <button class="type-option" data-type="drawing">ğŸ¨ ç»˜ç”»</button>
            <button class="type-option" data-type="cancel">âŒ å–æ¶ˆ</button>
        </div>
    </div>

    <script>
        class SandboxGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                
                // æ¸¸æˆçŠ¶æ€
                this.currentTool = 'draw';
                this.isDrawing = false;
                this.physicsEnabled = false;
                this.animationEnabled = false;
                this.controlEnabled = false;
                this.collisionDebugEnabled = false;
                
                // ç¢°æ’è®¾ç½®
                this.collisionSettings = {
                    stickman: true,
                    circle: true,
                    platform: true,
                    drawing: true,
                    group: true
                };
                
                // ç¢°æ’å½±å“ç¨‹åº¦è®¾ç½® (0-100%)
                this.collisionImpactSettings = {
                    stickman: 100,
                    circle: 100,
                    platform: 0,  // å¹³å°é»˜è®¤ä¸å—ç¢°æ’å½±å“
                    drawing: 100,
                    group: 100
                };
                
                // ç¢°æ’ç²¾åº¦è®¾ç½® (1-10)
                this.collisionPrecision = 5;
                this.collisionTolerance = 2; // åŸºç¡€ç¢°æ’å®¹å·®
                
                // ç±»å‹é€‰æ‹©å™¨
                this.typeSelectorVisible = false;
                this.objectToChange = null;
                
                // é€‰æ‹©ç›¸å…³
                this.isSelecting = false;
                this.selectionStart = null;
                this.selectionEnd = null;
                this.selectedObjects = [];
                
                // ç»˜ç”»è®¾ç½®
                this.currentColor = '#000000';
                this.brushSize = 3;
                
                // å¯¹è±¡
                this.drawnObjects = [];
                this.currentPath = [];
                this.selectedObject = null;
                
                // ç‰©ç†
                this.gravity = 0.5;
                this.friction = 0.98;
                
                // åŠ¨ç”»
                this.animationFrame = 0;
                
                // é”®ç›˜æ§åˆ¶
                this.keys = {};
                this.controlledObject = null;
                
                // äº’åŠ¨ç³»ç»Ÿ
                this.interactionEnabled = true;
                this.heldObject = null; // å½“å‰æŒæœ‰çš„å¯¹è±¡
                this.interactionRange = 50; // äº’åŠ¨èŒƒå›´
                this.interactionCooldown = 0; // äº’åŠ¨å†·å´æ—¶é—´
                
                this.setupEventListeners();
                this.gameLoop();
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight - 60;
            }
            
            setupEventListeners() {
                // å·¥å…·æŒ‰é’®
                document.getElementById('drawTool').addEventListener('click', () => this.setTool('draw'));
                document.getElementById('moveTool').addEventListener('click', () => this.setTool('move'));
                document.getElementById('selectTool').addEventListener('click', () => this.setTool('select'));
                document.getElementById('deleteTool').addEventListener('click', () => this.setTool('delete'));
                
                // è®¾ç½®
                document.getElementById('colorPicker').addEventListener('change', (e) => {
                    this.currentColor = e.target.value;
                });
                
                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushSizeValue').textContent = this.brushSize;
                });
                
                document.getElementById('clearCanvas').addEventListener('click', () => this.clearCanvas());
                document.getElementById('groupObjects').addEventListener('click', () => this.groupSelectedObjects());
                document.getElementById('ungroupObjects').addEventListener('click', () => this.ungroupSelectedObjects());
                document.getElementById('physicsToggle').addEventListener('click', () => this.togglePhysics());
                document.getElementById('animateToggle').addEventListener('click', () => this.toggleAnimation());
                document.getElementById('controlToggle').addEventListener('click', () => this.toggleControl());
                document.getElementById('collisionDebugToggle').addEventListener('click', () => this.toggleCollisionDebug());
                document.getElementById('changeTypeTool').addEventListener('click', () => this.setTool('changeType'));
                
                // ç¢°æ’è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
                document.getElementById('collisionStickman').addEventListener('change', (e) => {
                    this.collisionSettings.stickman = e.target.checked;
                });
                document.getElementById('collisionCircle').addEventListener('change', (e) => {
                    this.collisionSettings.circle = e.target.checked;
                });
                document.getElementById('collisionPlatform').addEventListener('change', (e) => {
                    this.collisionSettings.platform = e.target.checked;
                });
                document.getElementById('collisionDrawing').addEventListener('change', (e) => {
                    this.collisionSettings.drawing = e.target.checked;
                });
                document.getElementById('collisionGroup').addEventListener('change', (e) => {
                    this.collisionSettings.group = e.target.checked;
                });
                
                // ç¢°æ’å½±å“ç¨‹åº¦äº‹ä»¶ç›‘å¬å™¨
                document.getElementById('impactStickman').addEventListener('input', (e) => {
                    this.collisionImpactSettings.stickman = parseInt(e.target.value);
                    document.getElementById('impactStickmanValue').textContent = e.target.value + '%';
                });
                document.getElementById('impactCircle').addEventListener('input', (e) => {
                    this.collisionImpactSettings.circle = parseInt(e.target.value);
                    document.getElementById('impactCircleValue').textContent = e.target.value + '%';
                });
                document.getElementById('impactPlatform').addEventListener('input', (e) => {
                    this.collisionImpactSettings.platform = parseInt(e.target.value);
                    document.getElementById('impactPlatformValue').textContent = e.target.value + '%';
                });
                document.getElementById('impactDrawing').addEventListener('input', (e) => {
                    this.collisionImpactSettings.drawing = parseInt(e.target.value);
                    document.getElementById('impactDrawingValue').textContent = e.target.value + '%';
                });
                document.getElementById('impactGroup').addEventListener('input', (e) => {
                    this.collisionImpactSettings.group = parseInt(e.target.value);
                    document.getElementById('impactGroupValue').textContent = e.target.value + '%';
                });
                
                // ç¢°æ’ç²¾åº¦äº‹ä»¶ç›‘å¬å™¨
                document.getElementById('collisionPrecision').addEventListener('input', (e) => {
                    this.collisionPrecision = parseInt(e.target.value);
                    this.collisionTolerance = Math.max(0.5, 4 - this.collisionPrecision * 0.3);
                    document.getElementById('collisionPrecisionValue').textContent = this.collisionPrecision;
                    
                    // æ›´æ–°ä¿¡æ¯é¢æ¿æ˜¾ç¤º
                    document.getElementById('currentPrecision').textContent = this.collisionPrecision;
                    document.getElementById('currentTolerance').textContent = this.collisionTolerance.toFixed(1);
                });
                
                // ç±»å‹é€‰æ‹©å™¨äº‹ä»¶ç›‘å¬å™¨
                document.querySelectorAll('.type-option').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const type = e.target.dataset.type;
                        this.changeObjectType(type);
                    });
                });
                
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.onMouseUp());
                
                // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯æ”¯æŒï¼‰
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const mouseEvent = new MouseEvent('mouseup', {});
                    this.canvas.dispatchEvent(mouseEvent);
                });
                
                // çª—å£å¤§å°è°ƒæ•´
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // é”®ç›˜äº‹ä»¶
                window.addEventListener('keydown', (e) => this.onKeyDown(e));
                window.addEventListener('keyup', (e) => this.onKeyUp(e));
            }
            
            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                const cursors = {
                    draw: 'crosshair',
                    move: 'grab',
                    select: 'crosshair',
                    delete: 'not-allowed',
                    changeType: 'pointer'
                };
                this.canvas.style.cursor = cursors[tool] || 'default';
            }
            
            togglePhysics() {
                this.physicsEnabled = !this.physicsEnabled;
                const btn = document.getElementById('physicsToggle');
                btn.classList.toggle('active');
                btn.textContent = this.physicsEnabled ? 'âš¡ ç‰©ç†:å¼€' : 'âš¡ ç‰©ç†';
            }
            
            toggleAnimation() {
                this.animationEnabled = !this.animationEnabled;
                const btn = document.getElementById('animateToggle');
                btn.classList.toggle('active');
                btn.textContent = this.animationEnabled ? 'ğŸ¬ åŠ¨ç”»:å¼€' : 'ğŸ¬ åŠ¨ç”»';
            }
            
            toggleControl() {
                this.controlEnabled = !this.controlEnabled;
                const btn = document.getElementById('controlToggle');
                btn.classList.toggle('active');
                btn.textContent = this.controlEnabled ? 'ğŸ® æ§åˆ¶:å¼€' : 'ğŸ® é”®ç›˜æ§åˆ¶';
                
                if (this.controlEnabled) {
                    // è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªç«æŸ´äººæˆ–ç»„åˆå¯¹è±¡ä½œä¸ºæ§åˆ¶å¯¹è±¡
                    this.controlledObject = this.drawnObjects.find(obj => 
                        obj.type === 'stickman' || (obj.type === 'group' && this.hasStickmanInGroup(obj))
                    );
                    
                    if (this.controlledObject) {
                        this.selectedObjects = [this.controlledObject];
                    } else {
                        alert('è¯·å…ˆç»˜åˆ¶ä¸€ä¸ªç«æŸ´äººæˆ–é€‰æ‹©ä¸€ä¸ªåŒ…å«ç«æŸ´äººçš„ç»„åˆå¯¹è±¡ï¼');
                        this.controlEnabled = false;
                        btn.classList.remove('active');
                        btn.textContent = 'ğŸ® é”®ç›˜æ§åˆ¶';
                    }
                } else {
                    this.controlledObject = null;
                }
            }
            
            toggleCollisionDebug() {
                this.collisionDebugEnabled = !this.collisionDebugEnabled;
                const btn = document.getElementById('collisionDebugToggle');
                btn.classList.toggle('active');
                btn.textContent = this.collisionDebugEnabled ? 'ğŸ” ç¢°æ’è°ƒè¯•:å¼€' : 'ğŸ” ç¢°æ’è°ƒè¯•';
                
                // æ˜¾ç¤º/éšè—ç¢°æ’è®¾ç½®é¢æ¿
                const panel = document.getElementById('collisionPanel');
                if (this.collisionDebugEnabled) {
                    panel.classList.add('show');
                } else {
                    panel.classList.remove('show');
                }
            }
            
            hasStickmanInGroup(groupObj) {
                if (!groupObj.isGroup) return false;
                return groupObj.groupPaths.some(pathData => pathData.originalType === 'stickman');
            }
            
            onKeyDown(e) {
                if (!this.controlEnabled || !this.controlledObject) return;
                
                this.keys[e.code] = true;
                e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
            }
            
            onKeyUp(e) {
                if (!this.controlEnabled) return;
                
                this.keys[e.code] = false;
                e.preventDefault();
            }
            
            handleKeyboardControl() {
                if (!this.controlEnabled || !this.controlledObject) return;
                
                const moveSpeed = 5;
                const jumpPower = 12;
                let dx = 0, dy = 0;
                
                // æ°´å¹³ç§»åŠ¨ (A/D æˆ– å·¦å³æ–¹å‘é”®)
                if (this.keys['KeyA'] || this.keys['ArrowLeft']) {
                    dx = -moveSpeed;
                }
                if (this.keys['KeyD'] || this.keys['ArrowRight']) {
                    dx = moveSpeed;
                }
                
                // å‚ç›´ç§»åŠ¨ (W/S æˆ– ä¸Šä¸‹æ–¹å‘é”®)
                if (!this.physicsEnabled) {
                    // å¦‚æœç‰©ç†å…³é—­ï¼Œå¯ä»¥è‡ªç”±ä¸Šä¸‹ç§»åŠ¨
                    if (this.keys['KeyW'] || this.keys['ArrowUp']) {
                        dy = -moveSpeed;
                    }
                    if (this.keys['KeyS'] || this.keys['ArrowDown']) {
                        dy = moveSpeed;
                    }
                } else {
                    // å¦‚æœç‰©ç†å¼€å¯ï¼ŒWé”®æˆ–ä¸Šæ–¹å‘é”®ç”¨äºè·³è·ƒ
                    if ((this.keys['KeyW'] || this.keys['ArrowUp']) && this.controlledObject.isGrounded) {
                        this.controlledObject.velocity.y = -jumpPower;
                        this.controlledObject.isGrounded = false;
                    }
                }
                
                // åº”ç”¨ç§»åŠ¨
                if (dx !== 0 || dy !== 0) {
                    if (this.physicsEnabled && dx !== 0) {
                        // ç‰©ç†æ¨¡å¼ä¸‹ï¼Œæ°´å¹³ç§»åŠ¨å½±å“é€Ÿåº¦
                        this.controlledObject.velocity.x += dx * 0.3;
                        // é™åˆ¶æœ€å¤§é€Ÿåº¦
                        this.controlledObject.velocity.x = Math.max(-10, Math.min(10, this.controlledObject.velocity.x));
                    } else {
                        // éç‰©ç†æ¨¡å¼æˆ–å‚ç›´ç§»åŠ¨ï¼Œç›´æ¥ç§»åŠ¨ä½ç½®
                        this.moveObjectBy(this.controlledObject, dx, dy);
                    }
                }
                
                // æ·»åŠ è¡Œèµ°åŠ¨ç”»æ•ˆæœ
                if (dx !== 0 && this.animationEnabled) {
                    this.controlledObject.walkingAnimation = (this.controlledObject.walkingAnimation || 0) + 0.3;
                    this.controlledObject.animationPhase = Math.sin(this.controlledObject.walkingAnimation) * 0.15;
                } else {
                    this.controlledObject.walkingAnimation = 0;
                }
                
                // äº’åŠ¨åŠŸèƒ½ - Eé”®æ‹¾å–/æ”¾ä¸‹
                if (this.keys['KeyE'] && this.interactionCooldown <= 0) {
                    this.handleInteraction();
                    this.interactionCooldown = 10; // è®¾ç½®å†·å´æ—¶é—´
                }
                
                // æ›´æ–°å†·å´æ—¶é—´
                if (this.interactionCooldown > 0) {
                    this.interactionCooldown--;
                }
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            handleInteraction() {
                if (!this.controlledObject || this.controlledObject.type !== 'stickman') {
                    console.log('äº’åŠ¨å¤±è´¥ï¼šæ²¡æœ‰æ§åˆ¶å¯¹è±¡æˆ–ä¸æ˜¯ç«æŸ´äºº');
                    return; // åªæœ‰ç«æŸ´äººå¯ä»¥è¿›è¡Œäº’åŠ¨
                }
                
                if (this.heldObject) {
                    // æ”¾ä¸‹æŒæœ‰çš„å¯¹è±¡
                    this.dropHeldObject();
                } else {
                    // å°è¯•æ‹¾å–é™„è¿‘çš„å¯¹è±¡
                    this.pickupNearbyObject();
                }
            }
            
            pickupNearbyObject() {
                const stickman = this.controlledObject;
                let closestObject = null;
                let closestDistance = this.interactionRange;
                
                console.log(`å°è¯•æ‹¾å–ï¼Œæ§åˆ¶å¯¹è±¡ï¼š${stickman.type}ï¼Œæ€»å¯¹è±¡æ•°ï¼š${this.drawnObjects.length}`);
                
                for (const obj of this.drawnObjects) {
                    if (obj === stickman || obj.type === 'stickman') continue; // ä¸èƒ½æ‹¾å–å…¶ä»–ç«æŸ´äºº
                    
                    const distance = this.getDistance(stickman.center, obj.center);
                    console.log(`æ£€æŸ¥å¯¹è±¡ ${obj.type}ï¼Œè·ç¦»ï¼š${distance.toFixed(2)}`);
                    
                    if (distance < closestDistance) {
                        closestObject = obj;
                        closestDistance = distance;
                    }
                }
                
                if (closestObject) {
                    this.heldObject = closestObject;
                    closestObject.isHeld = true;
                    closestObject.heldBy = stickman;
                    
                    // æ·»åŠ è§†è§‰åé¦ˆ
                    closestObject.interactionEffect = 20;
                    
                    console.log(`ç«æŸ´äººæ‹¾å–äº† ${closestObject.type} å¯¹è±¡`);
                    console.log(`æŒæœ‰çŠ¶æ€: isHeld=${closestObject.isHeld}, heldBy=${closestObject.heldBy ? closestObject.heldBy.type : 'null'}`);
                } else {
                    console.log('æ²¡æœ‰æ‰¾åˆ°å¯æ‹¾å–çš„å¯¹è±¡');
                }
            }
            
            dropHeldObject() {
                if (!this.heldObject) return;
                
                const stickman = this.controlledObject;
                const obj = this.heldObject;
                
                // è®¡ç®—æ”¾ä¸‹ä½ç½®ï¼ˆåœ¨ç«æŸ´äººå‰æ–¹ï¼‰
                const dropOffset = 30;
                const direction = stickman.facingDirection || 1; // 1ä¸ºå³ï¼Œ-1ä¸ºå·¦
                
                obj.center.x = stickman.center.x + dropOffset * direction;
                obj.center.y = stickman.center.y;
                
                // ç§»é™¤æŒæœ‰çŠ¶æ€
                obj.isHeld = false;
                obj.heldBy = null;
                this.heldObject = null;
                
                // æ·»åŠ è§†è§‰åé¦ˆ
                obj.interactionEffect = 20;
                
                console.log(`ç«æŸ´äººæ”¾ä¸‹äº† ${obj.type} å¯¹è±¡`);
            }
            
            getDistance(pos1, pos2) {
                const dx = pos1.x - pos2.x;
                const dy = pos1.y - pos2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            onMouseDown(e) {
                const pos = this.getMousePos(e);
                
                switch(this.currentTool) {
                    case 'draw':
                        this.startDrawing(pos);
                        break;
                    case 'select':
                        this.startSelection(pos);
                        break;
                    case 'move':
                    case 'delete':
                        this.selectObject(pos);
                        break;
                    case 'changeType':
                        this.selectObjectForTypeChange(pos);
                        break;
                }
            }
            
            onMouseMove(e) {
                const pos = this.getMousePos(e);
                
                if (this.currentTool === 'draw' && this.isDrawing) {
                    this.continueDrawing(pos);
                } else if (this.currentTool === 'select' && this.isSelecting) {
                    this.updateSelection(pos);
                } else if (this.currentTool === 'move' && this.selectedObject) {
                    this.moveObject(pos);
                }
            }
            
            onMouseUp() {
                if (this.currentTool === 'draw' && this.isDrawing) {
                    this.finishDrawing();
                } else if (this.currentTool === 'select' && this.isSelecting) {
                    this.finishSelection();
                }
                this.isDrawing = false;
                this.isSelecting = false;
                this.selectedObject = null;
            }
            
            startDrawing(pos) {
                this.isDrawing = true;
                this.currentPath = [pos];
            }
            
            continueDrawing(pos) {
                this.currentPath.push(pos);
            }
            
            finishDrawing() {
                if (this.currentPath.length > 2) {
                    const object = this.createObjectFromPath(this.currentPath);
                    this.drawnObjects.push(object);
                    this.updateObjectsList();
                }
                this.currentPath = [];
            }
            
            startSelection(pos) {
                this.isSelecting = true;
                this.selectionStart = pos;
                this.selectionEnd = pos;
                this.selectedObjects = [];
            }
            
            updateSelection(pos) {
                this.selectionEnd = pos;
            }
            
            finishSelection() {
                if (this.selectionStart && this.selectionEnd) {
                    const minX = Math.min(this.selectionStart.x, this.selectionEnd.x);
                    const maxX = Math.max(this.selectionStart.x, this.selectionEnd.x);
                    const minY = Math.min(this.selectionStart.y, this.selectionEnd.y);
                    const maxY = Math.max(this.selectionStart.y, this.selectionEnd.y);
                    
                    this.selectedObjects = this.drawnObjects.filter(obj => {
                        return obj.center.x >= minX && obj.center.x <= maxX &&
                               obj.center.y >= minY && obj.center.y <= maxY;
                    });
                }
                
                this.selectionStart = null;
                this.selectionEnd = null;
            }
            
            selectObject(pos) {
                const clickedObject = this.drawnObjects.find(obj => {
                    return pos.x >= obj.bounds.minX && pos.x <= obj.bounds.maxX &&
                           pos.y >= obj.bounds.minY && pos.y <= obj.bounds.maxY;
                });
                
                if (clickedObject) {
                    if (this.currentTool === 'delete') {
                        this.deleteObject(clickedObject);
                    } else {
                        this.selectedObject = clickedObject;
                        // å¦‚æœå¯ç”¨äº†é”®ç›˜æ§åˆ¶ä¸”ç‚¹å‡»çš„æ˜¯ç«æŸ´äººï¼Œè®¾ä¸ºæ§åˆ¶å¯¹è±¡
                        if (this.controlEnabled && (clickedObject.type === 'stickman' || 
                            (clickedObject.type === 'group' && this.hasStickmanInGroup(clickedObject)))) {
                            this.controlledObject = clickedObject;
                            this.selectedObjects = [clickedObject];
                        }
                    }
                }
            }
            
            selectObjectForTypeChange(pos) {
                const clickedObject = this.drawnObjects.find(obj => {
                    return pos.x >= obj.bounds.minX && pos.x <= obj.bounds.maxX &&
                           pos.y >= obj.bounds.minY && pos.y <= obj.bounds.maxY;
                });
                
                if (clickedObject) {
                    this.objectToChange = clickedObject;
                    this.showTypeSelector();
                } else {
                    alert('è¯·ç‚¹å‡»ä¸€ä¸ªå¯¹è±¡æ¥æ”¹å˜å…¶ç±»å‹ï¼');
                }
            }
            
            showTypeSelector() {
                const selector = document.getElementById('typeSelector');
                selector.classList.add('show');
                this.typeSelectorVisible = true;
            }
            
            hideTypeSelector() {
                const selector = document.getElementById('typeSelector');
                selector.classList.remove('show');
                this.typeSelectorVisible = false;
                this.objectToChange = null;
            }
            
            changeObjectType(newType) {
                if (newType === 'cancel') {
                    this.hideTypeSelector();
                    return;
                }
                
                if (this.objectToChange) {
                    const oldType = this.objectToChange.type;
                    this.objectToChange.type = newType;
                    
                    // æ ¹æ®æ–°ç±»å‹è°ƒæ•´å¯¹è±¡çš„å±æ€§
                    this.adjustObjectProperties(this.objectToChange, newType);
                    
                    // æ›´æ–°å¯¹è±¡åˆ—è¡¨æ˜¾ç¤º
                    this.updateObjectsList();
                    
                    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    alert(`å·²å°† ${this.getTypeName(oldType)} æ”¹ä¸º ${this.getTypeName(newType)}`);
                    
                    this.hideTypeSelector();
                }
            }
            
            getTypeName(type) {
                const typeNames = {
                    stickman: 'ç«æŸ´äºº',
                    circle: 'åœ†å½¢',
                    platform: 'å¹³å°',
                    drawing: 'ç»˜ç”»',
                    group: 'ç»„åˆç‰©ä½“'
                };
                return typeNames[type] || type;
            }
            
            adjustObjectProperties(obj, newType) {
                switch (newType) {
                    case 'platform':
                        // å¹³å°é€šå¸¸ä¸éœ€è¦åŠ¨ç”»å’Œç‰©ç†
                        obj.velocity = { x: 0, y: 0 };
                        obj.isGrounded = true;
                        break;
                    case 'stickman':
                        // ç«æŸ´äººéœ€è¦åŠ¨ç”»å’Œç‰©ç†
                        obj.velocity = { x: 0, y: 0 };
                        obj.isGrounded = false;
                        break;
                    case 'circle':
                        // åœ†å½¢å¯ä»¥æ»šåŠ¨
                        obj.velocity = { x: 0, y: 0 };
                        obj.isGrounded = false;
                        break;
                    default:
                        // å…¶ä»–ç±»å‹ä¿æŒé»˜è®¤è®¾ç½®
                        break;
                }
            }
            
            moveObject(pos) {
                if (this.selectedObject) {
                    const dx = pos.x - this.selectedObject.center.x;
                    const dy = pos.y - this.selectedObject.center.y;
                    this.moveObjectBy(this.selectedObject, dx, dy);
                }
            }
            
            deleteObject(object) {
                const index = this.drawnObjects.indexOf(object);
                if (index > -1) {
                    this.drawnObjects.splice(index, 1);
                    this.updateObjectsList();
                }
            }
            
            clearCanvas() {
                this.drawnObjects = [];
                this.selectedObjects = [];
                this.updateObjectsList();
            }
            
            groupSelectedObjects() {
                if (this.selectedObjects.length < 2) {
                    alert('è¯·å…ˆé€‰æ‹©è‡³å°‘2ä¸ªç‰©ä½“å†è¿›è¡Œç»„åˆï¼');
                    return;
                }
                
                const group = this.createGroup(this.selectedObjects);
                
                // ä»åŸæ•°ç»„ä¸­ç§»é™¤è¢«ç»„åˆçš„å¯¹è±¡
                this.selectedObjects.forEach(obj => {
                    const index = this.drawnObjects.indexOf(obj);
                    if (index > -1) {
                        this.drawnObjects.splice(index, 1);
                    }
                });
                
                // æ·»åŠ ç»„åˆå¯¹è±¡
                this.drawnObjects.push(group);
                this.selectedObjects = [group];
                this.updateObjectsList();
            }
            
            ungroupSelectedObjects() {
                const groupsToUngroup = this.selectedObjects.filter(obj => obj.isGroup);
                
                if (groupsToUngroup.length === 0) {
                    alert('è¯·é€‰æ‹©è¦å–æ¶ˆç»„åˆçš„å¯¹è±¡ï¼');
                    return;
                }
                
                groupsToUngroup.forEach(group => {
                    // ç§»é™¤ç»„åˆå¯¹è±¡
                    const index = this.drawnObjects.indexOf(group);
                    if (index > -1) {
                        this.drawnObjects.splice(index, 1);
                    }
                    
                    // é‡æ–°åˆ›å»ºç‹¬ç«‹å¯¹è±¡
                    group.groupPaths.forEach(pathData => {
                        const newObj = {
                            id: Date.now() + Math.random(),
                            type: pathData.originalType || 'drawing',
                            path: [...pathData.path],
                            color: pathData.color,
                            lineWidth: pathData.lineWidth,
                            bounds: this.calculateBounds(pathData.path, pathData.lineWidth),
                            center: this.calculateCenter(pathData.path),
                            rotation: 0,
                            velocity: { x: 0, y: 0 },
                            animationPhase: 0,
                            isGrounded: false
                        };
                        this.drawnObjects.push(newObj);
                    });
                });
                
                this.selectedObjects = [];
                this.updateObjectsList();
            }
            
            createGroup(objects) {
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                const allPaths = [];
                objects.forEach(obj => {
                    if (obj.isGroup) {
                        // å¦‚æœæ˜¯ç»„åˆå¯¹è±¡ï¼Œæ·»åŠ å…¶æ‰€æœ‰å­è·¯å¾„
                        allPaths.push(...obj.groupPaths);
                    } else {
                        // æ™®é€šå¯¹è±¡ï¼Œæ·»åŠ å…¶è·¯å¾„
                        allPaths.push({
                            path: [...obj.path], // å¤åˆ¶è·¯å¾„
                            color: obj.color,
                            lineWidth: obj.lineWidth,
                            originalType: obj.type // ä¿å­˜åŸå§‹ç±»å‹
                        });
                    }
                    
                    // æ›´æ–°è¾¹ç•Œ
                    minX = Math.min(minX, obj.bounds.minX);
                    maxX = Math.max(maxX, obj.bounds.maxX);
                    minY = Math.min(minY, obj.bounds.minY);
                    maxY = Math.max(maxY, obj.bounds.maxY);
                });
                
                return {
                    id: Date.now(),
                    type: 'group',
                    isGroup: true,
                    groupPaths: allPaths,
                    path: [], // ç»„åˆå¯¹è±¡ä¸éœ€è¦å•ä¸€è·¯å¾„
                    color: '#27ae60',
                    lineWidth: 3,
                    bounds: { minX, maxX, minY, maxY },
                    center: {
                        x: (minX + maxX) / 2,
                        y: (minY + maxY) / 2
                    },
                    rotation: 0,
                    velocity: { x: 0, y: 0 },
                    animationPhase: 0,
                    isGrounded: false,
                    isHeld: false,
                    heldBy: null
                };
            }
            
            calculateCenter(path) {
                const bounds = this.calculateBounds(path, this.brushSize);
                return {
                    x: (bounds.minX + bounds.maxX) / 2,
                    y: (bounds.minY + bounds.maxY) / 2
                };
            }
            
            createObjectFromPath(path) {
                const type = this.detectObjectType(path);
                const bounds = this.calculateBounds(path, this.brushSize);
                
                return {
                    id: Date.now(),
                    type: type,
                    path: [...path],
                    color: this.currentColor,
                    lineWidth: this.brushSize,
                    bounds: bounds,
                    center: {
                        x: (bounds.minX + bounds.maxX) / 2,
                        y: (bounds.minY + bounds.maxY) / 2
                    },
                    rotation: 0,
                    velocity: { x: 0, y: 0 },
                    animationPhase: 0,
                    isGrounded: false,
                    isHeld: false,
                    heldBy: null
                };
            }
            
            detectObjectType(path) {
                const bounds = this.calculateBounds(path, this.brushSize);
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                
                if (this.isStickmanShape(path, bounds)) {
                    return 'stickman';
                } else if (Math.abs(width - height) < 30 && this.isCircular(path)) {
                    return 'circle';
                } else if (width > height * 2) {
                    return 'platform';
                } else {
                    return 'drawing';
                }
            }
            
            isStickmanShape(path, bounds) {
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                
                if (height <= width * 1.2) return false;
                
                const segments = this.analyzePathSegments(path);
                const hasVerticalTrunk = segments.verticalSegments > 0;
                const hasBranches = segments.branches >= 2;
                const hasComplexity = path.length > 20;
                
                return hasVerticalTrunk && hasBranches && hasComplexity;
            }
            
            analyzePathSegments(path) {
                let verticalSegments = 0;
                let branches = 0;
                
                for (let i = 1; i < path.length - 1; i++) {
                    const prev = path[i - 1];
                    const curr = path[i];
                    const next = path[i + 1];
                    
                    const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
                    const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
                    let angleDiff = Math.abs(angle2 - angle1);
                    
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    if (Math.abs(angle1) < Math.PI / 6 || Math.abs(angle1 - Math.PI) < Math.PI / 6) {
                        verticalSegments++;
                    }
                    
                    if (angleDiff > Math.PI / 3) {
                        branches++;
                    }
                }
                
                return { verticalSegments, branches };
            }
            
            isCircular(path) {
                const center = this.calculateBounds(path, this.brushSize);
                const centerX = (center.minX + center.maxX) / 2;
                const centerY = (center.minY + center.maxY) / 2;
                
                let avgDistance = 0;
                path.forEach(point => {
                    avgDistance += Math.sqrt((point.x - centerX) ** 2 + (point.y - centerY) ** 2);
                });
                avgDistance /= path.length;
                
                let variance = 0;
                path.forEach(point => {
                    const distance = Math.sqrt((point.x - centerX) ** 2 + (point.y - centerY) ** 2);
                    variance += (distance - avgDistance) ** 2;
                });
                variance /= path.length;
                
                return variance < avgDistance * 0.3;
            }
            
            calculateBounds(path, lineWidth = 3) {
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                // è€ƒè™‘çº¿å®½çš„ä¸€åŠä½œä¸ºè¾¹ç•Œæ‰©å±•
                const halfWidth = lineWidth / 2;
                
                path.forEach(point => {
                    minX = Math.min(minX, point.x - halfWidth);
                    maxX = Math.max(maxX, point.x + halfWidth);
                    minY = Math.min(minY, point.y - halfWidth);
                    maxY = Math.max(maxY, point.y + halfWidth);
                });
                
                return { minX, maxX, minY, maxY };
            }
            
            moveObjectBy(obj, dx, dy) {
                obj.center.x += dx;
                obj.center.y += dy;
                
                if (obj.isGroup) {
                    // å¯¹äºç»„åˆå¯¹è±¡ï¼Œç§»åŠ¨æ‰€æœ‰å­è·¯å¾„
                    obj.groupPaths.forEach(pathData => {
                        pathData.path.forEach(point => {
                            point.x += dx;
                            point.y += dy;
                        });
                    });
                } else {
                    // æ™®é€šå¯¹è±¡ç§»åŠ¨
                    obj.path.forEach(point => {
                        point.x += dx;
                        point.y += dy;
                    });
                }
                
                obj.bounds.minX += dx;
                obj.bounds.maxX += dx;
                obj.bounds.minY += dy;
                obj.bounds.maxY += dy;
            }
            
            update() {
                // å¤„ç†é”®ç›˜æ§åˆ¶
                this.handleKeyboardControl();
                
                // å¤„ç†è¢«æŒæœ‰ç‰©ä½“çš„è·Ÿéšï¼ˆæ— è®ºç‰©ç†æ˜¯å¦å¯ç”¨ï¼‰
                this.drawnObjects.forEach(obj => {
                    if (obj.isHeld && obj.heldBy) {
                        this.updateHeldObject(obj);
                    }
                });
                
                if (this.physicsEnabled) {
                    this.drawnObjects.forEach(obj => {
                        if (obj.type === 'platform') {
                            return;
                        }
                        
                        this.updateObjectPhysics(obj);
                    });
                    
                    // æ£€æµ‹å’Œå¤„ç†ç¢°æ’
                    this.detectCollisions();
                }
                
                if (this.animationEnabled) {
                    this.animationFrame += 0.1;
                    this.drawnObjects.forEach(obj => {
                        if (obj.type === 'stickman' || obj.type === 'group') {
                            // å¦‚æœä¸æ˜¯è¢«æ§åˆ¶çš„å¯¹è±¡æˆ–æ²¡æœ‰è¡Œèµ°åŠ¨ç”»ï¼Œä½¿ç”¨é»˜è®¤åŠ¨ç”»
                            if (obj !== this.controlledObject || !obj.walkingAnimation) {
                                obj.animationPhase = Math.sin(this.animationFrame) * 0.1;
                            }
                        }
                    });
                }
            }
            
            detectCollisions() {
                // æ ¹æ®ç¢°æ’ç²¾åº¦è°ƒæ•´æ£€æµ‹é¢‘ç‡
                const detectionInterval = Math.max(1, Math.floor(10 / this.collisionPrecision));
                
                for (let i = 0; i < this.drawnObjects.length; i++) {
                    for (let j = i + 1; j < this.drawnObjects.length; j++) {
                        // åœ¨é«˜ç²¾åº¦æ¨¡å¼ä¸‹ï¼Œå‡å°‘æ£€æµ‹é¢‘ç‡ä»¥æé«˜æ€§èƒ½
                        if (this.collisionPrecision >= 8 && (i + j) % detectionInterval !== 0) {
                            continue;
                        }
                        
                        const obj1 = this.drawnObjects[i];
                        const obj2 = this.drawnObjects[j];
                        
                        // æ£€æŸ¥ç¢°æ’è®¾ç½®
                        if (!this.shouldCollide(obj1, obj2)) {
                            continue;
                        }
                        
                        if (this.checkCollision(obj1, obj2)) {
                            this.resolveCollision(obj1, obj2);
                        }
                    }
                }
            }
            
            shouldCollide(obj1, obj2) {
                // æ£€æŸ¥ä¸¤ä¸ªå¯¹è±¡æ˜¯å¦éƒ½åº”è¯¥å‚ä¸ç¢°æ’
                const type1 = obj1.type;
                const type2 = obj2.type;
                
                // å¦‚æœä»»ä¸€ç±»å‹çš„ç¢°æ’è¢«ç¦ç”¨ï¼Œåˆ™ä¸ç¢°æ’
                if (!this.collisionSettings[type1] || !this.collisionSettings[type2]) {
                    return false;
                }
                
                // å¹³å°ä¸å¹³å°ä¸ç¢°æ’
                if (type1 === 'platform' && type2 === 'platform') {
                    return false;
                }
                
                return true;
            }
            
            checkCollision(obj1, obj2) {
                // é¦–å…ˆè¿›è¡ŒAABBç¢°æ’æ£€æµ‹ï¼ˆå¿«é€Ÿç­›é€‰ï¼‰
                const bounds1 = obj1.bounds;
                const bounds2 = obj2.bounds;
                
                // æ ¹æ®ç¢°æ’ç²¾åº¦è°ƒæ•´è¾¹ç•Œæ¡†æ‰©å±•
                const expansion = this.collisionTolerance * 2;
                
                if (bounds1.maxX + expansion < bounds2.minX - expansion || 
                    bounds1.minX - expansion > bounds2.maxX + expansion || 
                    bounds1.maxY + expansion < bounds2.minY - expansion || 
                    bounds1.minY - expansion > bounds2.maxY + expansion) {
                    return false;
                }
                
                // å¦‚æœAABBæ£€æµ‹é€šè¿‡ï¼Œè¿›è¡Œæ›´ç²¾ç¡®çš„è·¯å¾„ç¢°æ’æ£€æµ‹
                return this.checkPathCollision(obj1, obj2);
            }
            
            checkPathCollision(obj1, obj2) {
                const paths1 = this.getObjectPaths(obj1);
                const paths2 = this.getObjectPaths(obj2);
                
                for (const path1 of paths1) {
                    for (const path2 of paths2) {
                        if (this.checkPathIntersection(path1, path2)) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            getObjectPaths(obj) {
                if (obj.isGroup) {
                    return obj.groupPaths.map(pathData => pathData.path);
                } else {
                    return [obj.path];
                }
            }
            
            checkPathIntersection(path1, path2) {
                // ä½¿ç”¨å¯é…ç½®çš„ç¢°æ’ç²¾åº¦
                const tolerance = this.collisionTolerance;
                const precision = this.collisionPrecision;
                
                // æ ¹æ®ç²¾åº¦è°ƒæ•´æ£€æµ‹å¯†åº¦
                const step1 = Math.max(1, Math.floor(path1.length / (precision * 2)));
                const step2 = Math.max(1, Math.floor(path2.length / (precision * 2)));
                
                // è·³è¿‡è·¯å¾„çš„èµ·å§‹å’Œç»“æŸéƒ¨åˆ†ä»¥å‡å°‘ç«¯ç‚¹é»ä½
                const startSkip1 = Math.min(2, Math.floor(path1.length * 0.1));
                const endSkip1 = Math.max(path1.length - 3, path1.length - Math.floor(path1.length * 0.1));
                const startSkip2 = Math.min(2, Math.floor(path2.length * 0.1));
                const endSkip2 = Math.max(path2.length - 3, path2.length - Math.floor(path2.length * 0.1));
                
                for (let i = startSkip1; i < endSkip1; i += step1) {
                    const line1 = {
                        x1: path1[i].x,
                        y1: path1[i].y,
                        x2: path1[Math.min(i + 1, path1.length - 1)].x,
                        y2: path1[Math.min(i + 1, path1.length - 1)].y
                    };
                    
                    for (let j = startSkip2; j < endSkip2; j += step2) {
                        const line2 = {
                            x1: path2[j].x,
                            y1: path2[j].y,
                            x2: path2[Math.min(j + 1, path2.length - 1)].x,
                            y2: path2[Math.min(j + 1, path2.length - 1)].y
                        };
                        
                        if (this.checkLineIntersection(line1, line2, tolerance)) {
                            return true;
                        }
                    }
                }
                
                // é«˜ç²¾åº¦æ¨¡å¼ä¸‹çš„é¢å¤–æ£€æµ‹ï¼šæ£€æŸ¥ç‚¹åˆ°çº¿çš„è·ç¦»ï¼ˆä½†æ’é™¤ç«¯ç‚¹ï¼‰
                if (precision >= 7) {
                    return this.checkPointToPathDistance(path1, path2, tolerance) ||
                           this.checkPointToPathDistance(path2, path1, tolerance);
                }
                
                return false;
            }
            
            checkLineIntersection(line1, line2, tolerance = 0) {
                // æ£€æŸ¥ä¸¤æ¡çº¿æ®µæ˜¯å¦ç›¸äº¤ï¼Œæ”¯æŒå®¹å·®
                const det = (line1.x2 - line1.x1) * (line2.y2 - line2.y1) - 
                           (line2.x2 - line2.x1) * (line1.y2 - line1.y1);
                
                if (Math.abs(det) < 0.001) {
                    // å¹³è¡Œçº¿ï¼Œæ£€æŸ¥è·ç¦»
                    return this.checkParallelLineDistance(line1, line2, tolerance);
                }
                
                const t = ((line2.x1 - line1.x1) * (line2.y2 - line2.y1) - 
                          (line2.x2 - line2.x1) * (line2.y1 - line1.y1)) / det;
                const u = ((line1.x2 - line1.x1) * (line2.y1 - line1.y1) - 
                          (line2.y2 - line2.y1) * (line1.x1 - line2.x1)) / det;
                
                // æ”¹è¿›çš„å®¹å·®å¤„ç†ï¼šå‡å°‘ç«¯ç‚¹é™„è¿‘çš„æ•æ„Ÿæ€§
                const endpointTolerance = tolerance * 0.3; // ç«¯ç‚¹å®¹å·®æ›´å°
                const midTolerance = tolerance; // ä¸­é—´éƒ¨åˆ†å®¹å·®æ­£å¸¸
                
                // æ£€æŸ¥æ˜¯å¦åœ¨çº¿æ®µå†…éƒ¨ï¼ˆé¿å…ç«¯ç‚¹é»ä½é—®é¢˜ï¼‰
                const t_valid = (t >= endpointTolerance && t <= 1 - endpointTolerance) || 
                               (t >= -midTolerance && t <= 1 + midTolerance && 
                                (t > 0.2 && t < 0.8)); // åªåœ¨çº¿æ®µä¸­é—´éƒ¨åˆ†ä½¿ç”¨å¤§å®¹å·®
                                
                const u_valid = (u >= endpointTolerance && u <= 1 - endpointTolerance) || 
                               (u >= -midTolerance && u <= 1 + midTolerance && 
                                (u > 0.2 && u < 0.8)); // åªåœ¨çº¿æ®µä¸­é—´éƒ¨åˆ†ä½¿ç”¨å¤§å®¹å·®
                
                return t_valid && u_valid;
            }
            
            checkParallelLineDistance(line1, line2, tolerance) {
                // æ£€æŸ¥å¹³è¡Œçº¿ä¹‹é—´çš„è·ç¦»
                const dist1 = this.pointToLineDistance(line1.x1, line1.y1, line2);
                const dist2 = this.pointToLineDistance(line1.x2, line1.y2, line2);
                const dist3 = this.pointToLineDistance(line2.x1, line2.y1, line1);
                const dist4 = this.pointToLineDistance(line2.x2, line2.y2, line1);
                
                return Math.min(dist1, dist2, dist3, dist4) <= tolerance;
            }
            
            pointToLineDistance(px, py, line) {
                const A = px - line.x1;
                const B = py - line.y1;
                const C = line.x2 - line.x1;
                const D = line.y2 - line.y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                let isEndpoint = false;
                
                if (param < 0.1) { // å¢åŠ ç«¯ç‚¹ç¼“å†²åŒº
                    xx = line.x1;
                    yy = line.y1;
                    isEndpoint = true;
                } else if (param > 0.9) { // å¢åŠ ç«¯ç‚¹ç¼“å†²åŒº
                    xx = line.x2;
                    yy = line.y2;
                    isEndpoint = true;
                } else {
                    xx = line.x1 + param * C;
                    yy = line.y1 + param * D;
                    isEndpoint = false;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // å¦‚æœæ˜¯ç«¯ç‚¹ï¼Œå¢åŠ é¢å¤–çš„è·ç¦»æƒ©ç½šä»¥å‡å°‘é»ä½
                if (isEndpoint) {
                    return distance * 1.5; // ç«¯ç‚¹è·ç¦»å¢åŠ 50%çš„æƒ©ç½š
                }
                
                return distance;
            }
            
            checkPointToPathDistance(path1, path2, tolerance) {
                // æ£€æŸ¥è·¯å¾„1ä¸­çš„ç‚¹åˆ°è·¯å¾„2çš„è·ç¦»ï¼ˆé¿å…ç«¯ç‚¹ï¼‰
                const step = Math.max(1, Math.floor(path1.length / 10));
                
                // è·³è¿‡è·¯å¾„1çš„ç«¯ç‚¹éƒ¨åˆ†
                const startSkip = Math.min(2, Math.floor(path1.length * 0.15));
                const endSkip = Math.max(path1.length - 3, path1.length - Math.floor(path1.length * 0.15));
                
                for (let i = startSkip; i < endSkip; i += step) {
                    const point = path1[i];
                    let minDistance = Infinity;
                    
                    // æ‰¾åˆ°åˆ°è·¯å¾„2çš„æœ€çŸ­è·ç¦»ï¼ˆåŒæ ·è·³è¿‡è·¯å¾„2çš„ç«¯ç‚¹ï¼‰
                    const startSkip2 = Math.min(1, Math.floor(path2.length * 0.1));
                    const endSkip2 = Math.max(path2.length - 2, path2.length - Math.floor(path2.length * 0.1));
                    
                    for (let j = startSkip2; j < endSkip2; j++) {
                        const line = {
                            x1: path2[j].x,
                            y1: path2[j].y,
                            x2: path2[Math.min(j + 1, path2.length - 1)].x,
                            y2: path2[Math.min(j + 1, path2.length - 1)].y
                        };
                        
                        const distance = this.pointToLineDistance(point.x, point.y, line);
                        minDistance = Math.min(minDistance, distance);
                    }
                    
                    if (minDistance <= tolerance) {
                        return true;
                    }
                }
                
                return false;
            }
            
            resolveCollision(obj1, obj2) {
                // è·å–ç¢°æ’å½±å“ç¨‹åº¦
                const impact1 = this.collisionImpactSettings[obj1.type] / 100;
                const impact2 = this.collisionImpactSettings[obj2.type] / 100;
                
                // è®¡ç®—ç¢°æ’æ–¹å‘å’Œæ·±åº¦
                const overlapX = Math.min(obj1.bounds.maxX - obj2.bounds.minX, 
                                        obj2.bounds.maxX - obj1.bounds.minX);
                const overlapY = Math.min(obj1.bounds.maxY - obj2.bounds.minY, 
                                        obj2.bounds.maxY - obj1.bounds.minY);
                
                // é€‰æ‹©é‡å è¾ƒå°çš„è½´è¿›è¡Œåˆ†ç¦»
                if (overlapX < overlapY) {
                    // æ°´å¹³åˆ†ç¦» - æ ¹æ®å½±å“ç¨‹åº¦è°ƒæ•´åˆ†ç¦»è·ç¦»
                    if (obj1.bounds.minX < obj2.bounds.minX) {
                        this.moveObjectBy(obj1, -overlapX * 0.5 * impact1, 0);
                        this.moveObjectBy(obj2, overlapX * 0.5 * impact2, 0);
                    } else {
                        this.moveObjectBy(obj1, overlapX * 0.5 * impact1, 0);
                        this.moveObjectBy(obj2, -overlapX * 0.5 * impact2, 0);
                    }
                    
                    // äº¤æ¢æ°´å¹³é€Ÿåº¦ - æ ¹æ®å½±å“ç¨‹åº¦è°ƒæ•´é€Ÿåº¦äº¤æ¢
                    const tempVx = obj1.velocity.x;
                    obj1.velocity.x = obj2.velocity.x * 0.8 * impact2;
                    obj2.velocity.x = tempVx * 0.8 * impact1;
                } else {
                    // å‚ç›´åˆ†ç¦» - æ ¹æ®å½±å“ç¨‹åº¦è°ƒæ•´åˆ†ç¦»è·ç¦»
                    if (obj1.bounds.minY < obj2.bounds.minY) {
                        this.moveObjectBy(obj1, 0, -overlapY * 0.5 * impact1);
                        this.moveObjectBy(obj2, 0, overlapY * 0.5 * impact2);
                    } else {
                        this.moveObjectBy(obj1, 0, overlapY * 0.5 * impact1);
                        this.moveObjectBy(obj2, 0, -overlapY * 0.5 * impact2);
                    }
                    
                    // äº¤æ¢å‚ç›´é€Ÿåº¦ - æ ¹æ®å½±å“ç¨‹åº¦è°ƒæ•´é€Ÿåº¦äº¤æ¢
                    const tempVy = obj1.velocity.y;
                    obj1.velocity.y = obj2.velocity.y * 0.8 * impact2;
                    obj2.velocity.y = tempVy * 0.8 * impact1;
                    
                    // åœ°é¢å¯¹è±¡ç‰¹æ®Šå¤„ç† - å³ä½¿å½±å“ä¸º0ä¹Ÿè¦å¤„ç†åœ°é¢æ£€æµ‹
                    const groundTypes = ['platform', 'drawing', 'circle', 'stickman'];
                    if (groundTypes.includes(obj2.type)) {
                        obj1.isGrounded = true;
                        obj1.velocity.y = 0;
                    } else if (groundTypes.includes(obj1.type)) {
                        obj2.isGrounded = true;
                        obj2.velocity.y = 0;
                    }
                }
                
                // æ·»åŠ ç¢°æ’æ•ˆæœï¼ˆå¯é€‰ï¼‰
                this.addCollisionEffect(obj1, obj2);
            }
            
            addCollisionEffect(obj1, obj2) {
                // ä¸ºç¢°æ’çš„å¯¹è±¡æ·»åŠ è§†è§‰åé¦ˆ
                obj1.collisionEffect = 10;
                obj2.collisionEffect = 10;
                
                // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ éŸ³æ•ˆæˆ–å…¶ä»–æ•ˆæœ
                console.log(`ç¢°æ’: ${obj1.type} ä¸ ${obj2.type}`);
            }
            
            checkGroundCollision(obj) {
                // æ£€æŸ¥å¯¹è±¡æ˜¯å¦ä¸å…¶ä»–å¯¹è±¡ç¢°æ’ï¼ˆä½œä¸ºåœ°é¢ï¼‰
                const result = { isOnGround: false, groundY: 0 };
                
                for (const otherObj of this.drawnObjects) {
                    if (otherObj === obj) continue;
                    
                    // æ£€æŸ¥å¯ä»¥ä½œä¸ºåœ°é¢çš„å¯¹è±¡ç±»å‹ï¼šå¹³å°ã€ç»˜ç”»ã€åœ†å½¢ã€ç«æŸ´äºº
                    if (otherObj.type !== 'platform' && otherObj.type !== 'drawing' && 
                        otherObj.type !== 'circle' && otherObj.type !== 'stickman') continue;
                    
                    // æ£€æŸ¥ç¢°æ’è®¾ç½®
                    if (!this.collisionSettings[obj.type] || !this.collisionSettings[otherObj.type]) {
                        continue;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨å¯¹è±¡ä¸Šæ–¹
                    if (obj.bounds.maxY <= otherObj.bounds.minY) {
                        // é¢„æµ‹ä¸‹ä¸€å¸§çš„ä½ç½®
                        const nextY = obj.bounds.maxY + obj.velocity.y;
                        
                        if (nextY >= otherObj.bounds.minY && nextY <= otherObj.bounds.maxY) {
                            // æ£€æŸ¥æ°´å¹³ä½ç½®æ˜¯å¦é‡å 
                            if (obj.bounds.minX < otherObj.bounds.maxX && obj.bounds.maxX > otherObj.bounds.minX) {
                                // æ£€æŸ¥è·¯å¾„ç¢°æ’
                                if (this.checkPathCollision(obj, otherObj)) {
                                    result.isOnGround = true;
                                    result.groundY = otherObj.bounds.minY;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                return result;
            }
            
            updateHeldObject(obj) {
                const holder = obj.heldBy;
                const holdOffset = 20; // æŒæœ‰æ—¶çš„åç§»è·ç¦»
                
                console.log(`è·Ÿéšç§»åŠ¨: ${obj.type} è·Ÿéš ${holder.type} åˆ° (${holder.center.x.toFixed(1)}, ${holder.center.y.toFixed(1)})`);
                
                // è·ŸéšæŒæœ‰è€…ç§»åŠ¨
                obj.center.x = holder.center.x;
                obj.center.y = holder.center.y - holdOffset;
                
                // æ›´æ–°è¾¹ç•Œ
                obj.bounds = this.calculateBounds(obj.path, obj.lineWidth);
            }
            
            updateObjectPhysics(obj) {
                // å¦‚æœå¯¹è±¡è¢«æŒæœ‰ï¼Œè·ŸéšæŒæœ‰è€…ç§»åŠ¨
                if (obj.isHeld && obj.heldBy) {
                    this.updateHeldObject(obj);
                    return;
                }
                
                if (!obj.isGrounded) {
                    obj.velocity.y += this.gravity;
                }
                
                // æ£€æŸ¥ä¸ç”»å¸ƒåº•éƒ¨å’Œå…¶ä»–å¯¹è±¡çš„ç¢°æ’
                let isOnGround = false;
                const groundLevel = this.canvas.height - 20;
                
                // æ£€æŸ¥ç”»å¸ƒåº•éƒ¨
                if (obj.bounds.maxY + obj.velocity.y >= groundLevel) {
                    isOnGround = true;
                    obj.velocity.y = 0;
                    obj.velocity.x *= this.friction;
                    
                    const adjustY = groundLevel - obj.bounds.maxY;
                    this.moveObjectBy(obj, obj.velocity.x, adjustY);
                } else {
                    // æ£€æŸ¥ä¸å…¶ä»–å¯¹è±¡çš„ç¢°æ’ï¼ˆä½œä¸ºåœ°é¢ï¼‰
                    const collisionResult = this.checkGroundCollision(obj);
                    if (collisionResult.isOnGround) {
                        isOnGround = true;
                        obj.velocity.y = 0;
                        obj.velocity.x *= this.friction;
                        
                        // è°ƒæ•´ä½ç½®åˆ°ç¢°æ’å¯¹è±¡ä¸Šæ–¹
                        const adjustY = collisionResult.groundY - obj.bounds.maxY;
                        this.moveObjectBy(obj, obj.velocity.x, adjustY);
                    } else {
                        this.moveObjectBy(obj, obj.velocity.x, obj.velocity.y);
                    }
                }
                
                obj.isGrounded = isOnGround;
                
                if (obj.center.x < 50 || obj.center.x > this.canvas.width - 50) {
                    obj.velocity.x *= -0.5;
                }
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawGrid();
                
                // ç»˜åˆ¶å¯¹è±¡
                this.drawnObjects.forEach(obj => {
                    this.drawObject(obj);
                });
                
                // ç»˜åˆ¶å½“å‰è·¯å¾„
                if (this.currentPath.length > 0) {
                    this.drawPath(this.currentPath, this.currentColor, this.brushSize);
                }
                
                // ç»˜åˆ¶é€‰æ‹©æ¡†
                if (this.isSelecting && this.selectionStart && this.selectionEnd) {
                    this.drawSelectionBox();
                }
                
                // ç»˜åˆ¶é€‰ä¸­å¯¹è±¡çš„è¾¹æ¡†
                this.selectedObjects.forEach(obj => {
                    this.drawObjectBorder(obj);
                });
                
                // ç»˜åˆ¶ç¢°æ’è°ƒè¯•ä¿¡æ¯
                if (this.collisionDebugEnabled) {
                    this.drawCollisionDebug();
                }
            }
            
            drawGrid() {
                const gridSize = 40;
                this.ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            drawObject(obj) {
                this.ctx.save();
                
                if (obj.animationPhase && (obj.type === 'stickman' || obj.type === 'group')) {
                    this.ctx.translate(obj.center.x, obj.center.y);
                    this.ctx.rotate(obj.animationPhase);
                    this.ctx.translate(-obj.center.x, -obj.center.y);
                }
                
                // ç¢°æ’æ•ˆæœï¼šå¦‚æœå¯¹è±¡æœ‰ç¢°æ’æ•ˆæœï¼Œæ·»åŠ å‘å…‰æ•ˆæœ
                if (obj.collisionEffect && obj.collisionEffect > 0) {
                    this.ctx.shadowColor = '#ff6b6b';
                    this.ctx.shadowBlur = obj.collisionEffect;
                    obj.collisionEffect -= 0.5; // é€æ¸å‡å°‘æ•ˆæœ
                }
                
                // äº’åŠ¨æ•ˆæœï¼šå¦‚æœå¯¹è±¡è¢«æŒæœ‰ï¼Œæ·»åŠ ç‰¹æ®Šæ•ˆæœ
                if (obj.isHeld) {
                    this.ctx.shadowColor = '#3498db';
                    this.ctx.shadowBlur = 15;
                    this.ctx.strokeStyle = '#3498db';
                    this.ctx.lineWidth = obj.lineWidth + 2;
                }
                
                // äº’åŠ¨æ•ˆæœï¼šå¦‚æœå¯¹è±¡æœ‰äº’åŠ¨æ•ˆæœï¼Œæ·»åŠ å‘å…‰æ•ˆæœ
                if (obj.interactionEffect && obj.interactionEffect > 0) {
                    this.ctx.shadowColor = '#f39c12';
                    this.ctx.shadowBlur = obj.interactionEffect;
                    obj.interactionEffect -= 0.8; // é€æ¸å‡å°‘æ•ˆæœ
                }
                
                if (obj.isGroup) {
                    // ç»˜åˆ¶ç»„åˆå¯¹è±¡çš„æ‰€æœ‰å­è·¯å¾„
                    obj.groupPaths.forEach(pathData => {
                        this.drawPath(pathData.path, pathData.color, pathData.lineWidth);
                    });
                    
                    // ç»˜åˆ¶ç»„åˆè¾¹æ¡†ï¼ˆå¯é€‰ï¼‰
                    this.ctx.strokeStyle = 'rgba(39, 174, 96, 0.3)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(
                        obj.bounds.minX - 2,
                        obj.bounds.minY - 2,
                        obj.bounds.maxX - obj.bounds.minX + 4,
                        obj.bounds.maxY - obj.bounds.minY + 4
                    );
                    this.ctx.setLineDash([]);
                } else {
                    // ç»˜åˆ¶æ™®é€šå¯¹è±¡
                    this.drawPath(obj.path, obj.color, obj.lineWidth);
                }
                
                this.ctx.restore();
            }
            
            drawPath(path, color, lineWidth) {
                if (path.length < 2) return;
                
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = lineWidth;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(path[0].x, path[0].y);
                
                for (let i = 1; i < path.length; i++) {
                    this.ctx.lineTo(path[i].x, path[i].y);
                }
                
                this.ctx.stroke();
            }
            
            drawSelectionBox() {
                const minX = Math.min(this.selectionStart.x, this.selectionEnd.x);
                const maxX = Math.max(this.selectionStart.x, this.selectionEnd.x);
                const minY = Math.min(this.selectionStart.y, this.selectionEnd.y);
                const maxY = Math.max(this.selectionStart.y, this.selectionEnd.y);
                
                this.ctx.strokeStyle = 'rgba(0, 123, 255, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
                
                this.ctx.fillStyle = 'rgba(0, 123, 255, 0.1)';
                this.ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
                
                this.ctx.setLineDash([]);
            }
            
            drawObjectBorder(obj) {
                const padding = 5;
                this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([3, 3]);
                this.ctx.strokeRect(
                    obj.bounds.minX - padding,
                    obj.bounds.minY - padding,
                    obj.bounds.maxX - obj.bounds.minX + padding * 2,
                    obj.bounds.maxY - obj.bounds.minY + padding * 2
                );
                this.ctx.setLineDash([]);
            }
            
            drawCollisionDebug() {
                // ç»˜åˆ¶æ‰€æœ‰å¯¹è±¡çš„è¾¹ç•Œæ¡†å’Œç²¾ç¡®ç¢°æ’åŒºåŸŸ
                this.drawnObjects.forEach(obj => {
                    // ç»˜åˆ¶è¾¹ç•Œæ¡†
                    this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(
                        obj.bounds.minX,
                        obj.bounds.minY,
                        obj.bounds.maxX - obj.bounds.minX,
                        obj.bounds.maxY - obj.bounds.minY
                    );
                    
                    // ç»˜åˆ¶ç²¾ç¡®çš„ç¢°æ’åŒºåŸŸ
                    this.drawPreciseCollisionArea(obj);
                    
                    // ç»˜åˆ¶å¯¹è±¡ä¸­å¿ƒç‚¹
                    this.ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.arc(obj.center.x, obj.center.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // æ˜¾ç¤ºå¯¹è±¡ç±»å‹ã€ç¢°æ’å½±å“ç¨‹åº¦å’Œç²¾åº¦ä¿¡æ¯
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.font = '12px Arial';
                    const impact = this.collisionImpactSettings[obj.type];
                    const impactText = impact === 0 ? 'æ— å½±å“' : `${impact}%`;
                    const precisionText = `ç²¾åº¦:${this.collisionPrecision}`;
                    this.ctx.fillText(`${obj.type} (${impactText})`, obj.bounds.minX, obj.bounds.minY - 5);
                    this.ctx.fillText(precisionText, obj.bounds.minX, obj.bounds.minY - 20);
                });
                
                // æ£€æµ‹å¹¶æ˜¾ç¤ºç¢°æ’
                for (let i = 0; i < this.drawnObjects.length; i++) {
                    for (let j = i + 1; j < this.drawnObjects.length; j++) {
                        const obj1 = this.drawnObjects[i];
                        const obj2 = this.drawnObjects[j];
                        
                        // æ£€æŸ¥ç¢°æ’è®¾ç½®
                        if (!this.shouldCollide(obj1, obj2)) {
                            continue;
                        }
                        
                        if (this.checkCollision(obj1, obj2)) {
                            // æ ¹æ®ç¢°æ’å½±å“ç¨‹åº¦é€‰æ‹©é¢œè‰²
                            const impact1 = this.collisionImpactSettings[obj1.type];
                            const impact2 = this.collisionImpactSettings[obj2.type];
                            const avgImpact = (impact1 + impact2) / 2;
                            
                            let lineColor, pointColor;
                            if (avgImpact === 0) {
                                lineColor = 'rgba(128, 128, 128, 0.5)'; // ç°è‰² - æ— å½±å“
                                pointColor = 'rgba(128, 128, 128, 0.5)';
                            } else if (avgImpact < 50) {
                                lineColor = 'rgba(255, 165, 0, 0.8)'; // æ©™è‰² - å¼±å½±å“
                                pointColor = 'rgba(255, 165, 0, 0.8)';
                            } else {
                                lineColor = 'rgba(255, 0, 0, 0.8)'; // çº¢è‰² - å¼ºå½±å“
                                pointColor = 'rgba(255, 0, 0, 0.8)';
                            }
                            
                            // ç»˜åˆ¶ç¢°æ’è¿çº¿
                            this.ctx.strokeStyle = lineColor;
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(obj1.center.x, obj1.center.y);
                            this.ctx.lineTo(obj2.center.x, obj2.center.y);
                            this.ctx.stroke();
                            
                            // ç»˜åˆ¶ç¢°æ’ç‚¹
                            this.ctx.fillStyle = pointColor;
                            this.ctx.beginPath();
                            this.ctx.arc(
                                (obj1.center.x + obj2.center.x) / 2,
                                (obj1.center.y + obj2.center.y) / 2,
                                5, 0, Math.PI * 2
                            );
                            this.ctx.fill();
                        }
                    }
                }
            }
            
            drawPreciseCollisionArea(obj) {
                // ç»˜åˆ¶ç²¾ç¡®çš„ç¢°æ’åŒºåŸŸï¼ŒåŸºäºå®é™…è·¯å¾„
                const paths = this.getObjectPaths(obj);
                
                paths.forEach(path => {
                    if (path.length < 2) return;
                    
                    // ç»˜åˆ¶è·¯å¾„çš„ç²¾ç¡®ç¢°æ’åŒºåŸŸ
                    this.ctx.strokeStyle = 'rgba(255, 0, 255, 0.6)';
                    this.ctx.lineWidth = this.collisionTolerance * 2;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(path[0].x, path[0].y);
                    
                    for (let i = 1; i < path.length; i++) {
                        this.ctx.lineTo(path[i].x, path[i].y);
                    }
                    
                    this.ctx.stroke();
                    
                    // åœ¨é«˜ç²¾åº¦æ¨¡å¼ä¸‹ï¼Œæ˜¾ç¤ºæ£€æµ‹ç‚¹
                    if (this.collisionPrecision >= 8) {
                        this.ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                        const step = Math.max(1, Math.floor(path.length / 20));
                        
                        for (let i = 0; i < path.length; i += step) {
                            this.ctx.beginPath();
                            this.ctx.arc(path[i].x, path[i].y, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                });
            }
            
            updateObjectsList() {
                const list = document.getElementById('objectsList');
                if (this.drawnObjects.length === 0) {
                    list.textContent = 'æš‚æ— ';
                } else {
                    const counts = {};
                    this.drawnObjects.forEach(obj => {
                        counts[obj.type] = (counts[obj.type] || 0) + 1;
                    });
                    
                    const typeNames = {
                        stickman: 'ç«æŸ´äºº',
                        circle: 'åœ†å½¢',
                        platform: 'å¹³å°',
                        drawing: 'ç»˜ç”»',
                        group: 'ç»„åˆç‰©ä½“'
                    };
                    
                    list.innerHTML = Object.entries(counts)
                        .map(([type, count]) => `${typeNames[type] || type}: ${count}`)
                        .join('<br>');
                }
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // å¯åŠ¨æ¸¸æˆ
        new SandboxGame();
    </script>
</body>
</html>